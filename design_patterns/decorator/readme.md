# 데코레이터 패턴

## 시나리오 개요
- 단기간에 폭발 성장한 스타벅스의 주문 시스템을 개선하자
- 고객은 커피를 주문할 때 토핑을 추가하고, 각각을 선택할 때 커피 가격이 올라가야 한다
- 상속을 이용한다면 Beverage를 상속받는 모든 서브클래스는 토핑에 대한 코드를 추가해야 한다. 또한 토핑이 추가/제거될 경우 모든 서브 클래스에 수정이 필요하다

예시
```ruby
class Beverage
  def cost; end

  def hasMilk; end
  def setMilk; end
  def hasSoy; end
  def setSoy; end
  def setMocha; end
  def hasMocha; end
  ...
end
```

### 상속과 구성
- 상속을 사용한다고 무조건 유연하고 관리하기 쉬운 디자인이 만들어지지 않는다. 상속을 사용하면 모든 서브 클래스에서 똑같은 행동을 상속받아야 한다
- 구성과 위임으로 실행중에 행동을 상속하는 방법이 있다. 구성으로 객체의 행동을 확장하면 실행 중에 동적으로 행동을 설정할 수 있다.
- 객체를 동적으로 구성하면 기존 코드를 고치는 대신 새로운 코드를 만들어서 기능을 추가할 수 있다. 기존 코드를 수정하지 않아 의도치 않은 버그를 차단할 수 있다

## OCP(Open-Closed Principle)
> 클래스는 확장에는 열려 있지만, 변경에는 닫혀 있어야 한다

- OCP를 통해 변경에 유연한 디자인을 만들 수 있다
  - 기존 코드를 건드리지 않고 확장할 수 있는 코드
- 무조건 OCP를 적용한다고 좋은 것은 아니다. 시간 낭비 및 추상화로 인해 코드가 복잡해질 수 있다
- 여러 디자인을 공부하며 중요한(바뀔 가능성이 높은) 부분에 OCP를 적용하는 것이 좋다

## 데코레이터 패턴 살펴보기
- 상속을 써서 음료 가격과 토핑 가격을 모두 합하는 방법은 클래스가 매우 많아지거나, 일부 서브 클래스에는 적합하지 않은 기능을 추가해야 했다
- 데코레이터 패턴을 '래퍼' 객체로 생각해 음료를 장식한다고 생각해보자
  1. DarkRoast 객체를 가져온다
  2. Mocha 객체로 장식한다
  3. Whip 객체로 장식한다
  4. cost() 메서드를 호출한다.
    - 토핑의 가격으 계산하는 일은 해당 객체에게 위임한다

### 주문 시스템에 데코레이터 패턴 적용하기
아래 이미지들만 잘 이해하면 된다
![image](https://github.com/jwowo/study/assets/72483138/c12240a0-4863-4b73-9641-5fe4f2719555)
- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있다
- 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 외에 추가 작업을 수행할 수 있다
- 객체는 언제든 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있다

![image](https://github.com/jwowo/study/assets/72483138/b1001793-9211-4f52-89e2-a6fd3b529ce8)
![image](https://github.com/jwowo/study/assets/72483138/7fdf3927-6348-4cd7-8d61-7c539f8f9d11)
- 컴포넌트
  - 직접 쓰일 수도 있고 데코레이터에 감싸여 쓰일 수도 있다
- 데코레이터
  - 컴포넌트의 인스턴스 변수를 저장한다
  - 자신이 장식할 구성 요소와 같은 인터페이스 또는 추상 클래스를 구현한다
  - 컴포넌트의 상태를 확장할 수 있다
  - 새로운 메서드를 추가할 수 있지만, 일반적으로 새로운 메서드를 추가하지 않고 컴포넌트에 원래 있던 메서드를 호출 후 별도의 작업으로 처리해서 새로운 기능을 추가한다


